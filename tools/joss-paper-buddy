#!/usr/bin/env python

import sys
import argparse
from ruamel.yaml import YAML
from io import StringIO

yaml = YAML()
yaml.indent(mapping=2, sequence=3, offset=1)
yaml.width = 1000  # Set a high value to prevent wrapping

def parse_markdown_file(file_path):
    """ Parses the YAML front matter from a Markdown file, preserving comments. """
    with open(file_path, 'r') as file:
        content = file.read()

    parts = content.split('---', 2)
    if len(parts) < 3:
        raise ValueError("Invalid Markdown file format. Missing '---' delimiters.")
    
    yaml_content = yaml.load(parts[1])
    return yaml_content, parts[0], parts[2]

def create_cff_record(yaml_data):
    """ Generates a dictionary for a CITATION.cff file from parsed YAML data. """
    cff = {
        'cff-version': '1.2.0',
        'message': 'If you use this software, please cite it using these metadata.',
        'title': yaml_data['title'],
        'authors': [],
        'keywords': yaml_data['tags'],
    }
    
    # Prepare affiliations map
    affiliations = {aff['index']: aff['name'] for aff in yaml_data['affiliations']}
    
    # Populate authors, de-referencing affiliations
    for author in yaml_data['authors']:
        author_entry = {}
        author['name']
        author_entry['given-names'], author_entry['family-names'] = author['name'].rsplit(' ', 1)
        if orcid := author.get('orcid'):
            if not orcid.startswith('http'):
                orcid = f"https://orcid.org/{orcid}"
            author_entry['orcid'] = orcid

        # Resolve affiliations
        author_affiliations = [int(a.strip()) for a in str(author['affiliation']).split(',')]
        # CFF does not yet support multiple affiliations, so join via &
        author_entry['affiliation'] = ' & '.join(
            affiliations[aff] for aff in author_affiliations
        )
        cff['authors'].append(author_entry)
    return cff

def save_cff_file(cff_data, output_path='CITATION.cff'):
    """ Saves the CITATION.cff data to a file. """
    with open(output_path, 'w') as file:
        yaml.dump(cff_data, file)

def fixup_affiliations(yaml_data):
    """ Normalizes and sorts the affiliations to ensure sequential indices without gaps. """

    reindex_map = {}
    highest_seen = 0
    for author in yaml_data['authors']:
        author_affiliations = [int(a.strip()) for a in str(author['affiliation']).split(',')]
        fixed_affiliations = []
        for aff in author_affiliations:
            if aff in reindex_map:
                fixed_affiliations.append(reindex_map[aff])
            else:
                # It will become the new highest seen
                highest_seen += 1
                reindex_map[aff] = highest_seen
                fixed_affiliations.append(highest_seen)
        new_aff = ', '.join(map(str, fixed_affiliations)).strip()
        author['affiliation'] = int(new_aff) if new_aff.isdigit() else new_aff

    affiliations = yaml_data['affiliations']
    index_map = {
        aff['index']: aff['name']
        for aff in yaml_data['affiliations']
    }

    # now create new affiliations
    yaml_data['affiliations'] = [
        {'name': index_map[old_index],
         'index': int(new_index)}
        for old_index, new_index in reindex_map.items()
    ]

    return yaml_data

def main():
    parser = argparse.ArgumentParser(description="Process markdown files and produce metadata files.")
    parser.add_argument("command", choices=["produce-citation.cff", "produce-zenodo.json", "fixup-affiliations"], help="Command to execute.")
    parser.add_argument("markdown_file_path", nargs='?', default='paper.md', help="Path to the markdown file (default: paper.md)")

    args = parser.parse_args()

    yaml_data, pre_yaml, post_yaml = parse_markdown_file(args.markdown_file_path)

    if args.command == "produce-citation.cff":
        cff_data = create_cff_record(yaml_data)
        save_cff_file(cff_data)
    elif args.command == "produce-zenodo.json":
        # Placeholder for produce-zenodo.json implementation
        print("produce-zenodo.json not implemented yet.")
    elif args.command == "fixup-affiliations":
        fixed_yaml_data = fixup_affiliations(yaml_data)
        yaml_buffer = StringIO()
        yaml.dump(fixed_yaml_data, yaml_buffer)
        fixed_yaml_str = yaml_buffer.getvalue()

        with open(args.markdown_file_path, 'w') as file:
            file.write(pre_yaml + '---\n' + fixed_yaml_str + '---\n' + post_yaml)
        print("Affiliations have been fixed and saved.")

if __name__ == "__main__":
    main()
